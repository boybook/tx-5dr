import React, { useState, useEffect, useMemo } from 'react';
import {
  Table,
  TableHeader,
  TableColumn,
  TableBody,
  TableRow,
  TableCell,
  Button,
  Input,
  Chip,
  Pagination,
  Spinner,
  Dropdown,
  DropdownTrigger,
  DropdownMenu,
  DropdownItem,
  Alert,
  Modal,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalFooter,
  Tooltip,
  ButtonGroup,
  Select,
  SelectItem,
} from '@heroui/react';
import { SearchIcon } from '@heroui/shared-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faChevronDown, faSync, faDownload, faUpload, faExternalLinkAlt, faEdit, faTrash } from '@fortawesome/free-solid-svg-icons';
import type { QSORecord, LogBookStatistics, WaveLogSyncResponse } from '@tx5dr/contracts';
import { api, WSClient } from '@tx5dr/core';
import { getLogbookWebSocketUrl } from '../utils/config';
import { isElectron } from '../utils/config';

interface LogbookViewerProps {
  operatorId: string;
  logBookId?: string;
  operatorCallsign?: string;
}

interface QSOFilters {
  callsign?: string;
  band?: string;
  mode?: string;
  startDate?: string;
  endDate?: string;
}

const LogbookViewer: React.FC<LogbookViewerProps> = ({ operatorId, logBookId, operatorCallsign }) => {
  const [qsos, setQsos] = useState<QSORecord[]>([]);
  const [statistics, setStatistics] = useState<LogBookStatistics | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<QSOFilters>({});
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(50);
  const [totalRecords, setTotalRecords] = useState(0);
  const [actualTotalRecords, setActualTotalRecords] = useState(0);
  const [hasFilters, setHasFilters] = useState(false);
  const [sortDescriptor, setSortDescriptor] = useState<{
    column: string;
    direction: 'ascending' | 'descending';
  }>({ column: 'startTime', direction: 'descending' });
  const [isSearchExpanded, setIsSearchExpanded] = useState(false);

  // ÁºñËæë Modal Áä∂ÊÄÅ
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [editingQSO, setEditingQSO] = useState<QSORecord | null>(null);
  const [editFormData, setEditFormData] = useState<Partial<QSORecord>>({});
  const [isEditSaving, setIsEditSaving] = useState(false);

  // Âà†Èô§Á°ÆËÆ§ Modal Áä∂ÊÄÅ
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [deletingQSO, setDeletingQSO] = useState<QSORecord | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // Ëé∑ÂèñÊìç‰ΩúÂëòËøûÊé•ÁöÑÊó•ÂøóÊú¨
  // Êó•ÂøóÊú¨IDÂ∞±ÊòØÂëºÂè∑ÔºåÂ¶ÇÊûúÊ≤°ÊúâÊåáÂÆöÂàô‰ΩøÁî®Êìç‰ΩúÂëòID‰Ωú‰∏∫ÂêéÂ§á
  const effectiveLogBookId = logBookId || operatorId;
  
  // Êó•ÂøóÊú¨‰∏ìÁî®WebSocketÔºöÂè™Êé•Êî∂ËΩªÈáèÈÄöÁü•ÔºåÁÑ∂Âêé‰∏ªÂä®Âà∑Êñ∞
  useEffect(() => {
    // ‰ªÖÊåâ operatorId ËÆ¢ÈòÖÔºåÈÅøÂÖç logBookId ‰∏ç‰∏ÄËá¥ÂØºËá¥ËøáÊª§Â§±Ë¥•
    const url = getLogbookWebSocketUrl({ operatorId });
    const client = new WSClient({ url, reconnectAttempts: -1, reconnectDelay: 1000, heartbeatInterval: 30000 });
    
    const refresh = () => {
      // ‰øùÊåÅÂΩìÂâçÁ≠õÈÄâ‰∏éÂàÜÈ°µÔºåÈáçÊñ∞Âä†ËΩΩ
      loadQSOs();
      loadStatistics();
    };
    
    client.onWSEvent('logbookChangeNotice' as any, (payload: { logBookId?: string; operatorId?: string }) => {
      if (!payload) return;
      // ‰ª• operatorId ‰∏∫‰∏ªËøõË°åÂåπÈÖçÔºõÂÖ∂Ê¨°Â∞ùËØï logBookId
      if (payload.operatorId === operatorId || (payload.logBookId && payload.logBookId === effectiveLogBookId)) {
        console.log('üîî Êî∂Âà∞Êó•ÂøóÊú¨ÂèòÊõ¥ÈÄöÁü•ÔºåÂà∑Êñ∞Êï∞ÊçÆ');
        refresh();
      }
    });
    client.connect().catch(() => {});
    
    return () => {
      client.disconnect();
    };
  }, [operatorId, effectiveLogBookId]);

  // Âä†ËΩΩQSOËÆ∞ÂΩï
  const loadQSOs = async () => {
    try {
      setLoading(true);
      setError(null);
      const queryOptions = {
        ...filters,
        limit: itemsPerPage,
        offset: (currentPage - 1) * itemsPerPage,
      };
      
      console.log('üìä [LogbookViewer] ÂèëÈÄÅAPIËØ∑Ê±Ç:', {
        effectiveLogBookId,
        queryOptions,
        currentPage,
        itemsPerPage,
        calculatedOffset: (currentPage - 1) * itemsPerPage
      });
      
      const response = await api.getLogBookQSOs(effectiveLogBookId, queryOptions);
      console.log('üìä [LogbookViewer] APIÂìçÂ∫î:', { 
        dataLength: response.data.length, 
        meta: response.meta,
        filteredTotal: response.meta?.total,
        actualTotalRecords: response.meta?.totalRecords,
        currentPage,
        itemsPerPage,
        calculatedTotalPages: Math.ceil((response.meta?.total || response.data.length) / itemsPerPage)
      });
      setQsos(response.data);
      // ‰ΩøÁî®Á≠õÈÄâÂêéÁöÑÊÄªÊï∞Êù•ËÆ°ÁÆóÂàÜÈ°µ
      setTotalRecords(response.meta?.total || response.data.length);
      // ‰øùÂ≠òÂÆûÈôÖÊÄªËÆ∞ÂΩïÊï∞Áî®‰∫éÊòæÁ§∫
      setActualTotalRecords(response.meta?.totalRecords || response.data.length);
      setHasFilters(response.meta?.hasFilters || false);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Âä†ËΩΩQSOËÆ∞ÂΩïÂ§±Ë¥•';
      console.error('Âä†ËΩΩQSOËÆ∞ÂΩïÂ§±Ë¥•:', error);
      setError(errorMessage);
      setQsos([]); // Ê∏ÖÁ©∫Êï∞ÊçÆ
    } finally {
      setLoading(false);
    }
  };

  // Âä†ËΩΩÁªüËÆ°‰ø°ÊÅØ
  const loadStatistics = async () => {
    try {
      const response = await api.getLogBook(effectiveLogBookId);
      setStatistics(response.data.statistics);
    } catch (error) {
      console.error('Âä†ËΩΩÁªüËÆ°‰ø°ÊÅØÂ§±Ë¥•:', error);
      // ÁªüËÆ°‰ø°ÊÅØÂä†ËΩΩÂ§±Ë¥•‰∏çÂΩ±ÂìçQSOËÆ∞ÂΩïÁöÑÊòæÁ§∫
      setStatistics(null);
    }
  };

  // ÂàùÂßãÂä†ËΩΩ‰∏éÁ≠õÈÄâ/ÂàÜÈ°µÂèòÂåñÊó∂Âä†ËΩΩ
  useEffect(() => {
    loadQSOs();
    loadStatistics();
  }, [effectiveLogBookId, filters, currentPage]);

  // ÊÄªÈ°µÊï∞ËÆ°ÁÆó - Âü∫‰∫éÁ≠õÈÄâÂêéÁöÑËÆ∞ÂΩïÊï∞
  const totalPages = useMemo(() => {
    const pages = Math.ceil(totalRecords / itemsPerPage);
    return pages;
  }, [totalRecords, itemsPerPage, currentPage]);

  // ÂØºÂá∫ÂäüËÉΩÔºàÂ¢ûÂº∫ÈîôËØØÂ§ÑÁêÜÔºâ
  const [isExporting, setIsExporting] = useState(false);
  const [exportError, setExportError] = useState<string | null>(null);
  
  // WaveLogÂêåÊ≠•ÂäüËÉΩ
  const [isSyncing, setIsSyncing] = useState(false);
  const [syncError, setSyncError] = useState<string | null>(null);
  const [syncSuccess, setSyncSuccess] = useState<string | null>(null);
  
  const handleExport = async (format: 'adif' | 'csv') => {
    if (isExporting) return;
    
    try {
      setIsExporting(true);
      setExportError(null);
      
      const exportData = await api.exportLogBook(effectiveLogBookId, {
        format,
        ...filters,
      });
      
      const blob = new Blob([exportData], { 
        type: format === 'adif' ? 'text/plain' : 'text/csv' 
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `logbook_${operatorId}_${new Date().toISOString().split('T')[0]}.${format}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log(`üìä ÊàêÂäüÂØºÂá∫ ${format.toUpperCase()} Ê†ºÂºèÊó•Âøó`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ÂØºÂá∫Â§±Ë¥•';
      console.error('ÂØºÂá∫Â§±Ë¥•:', error);
      setExportError(errorMessage);
    } finally {
      setIsExporting(false);
    }
  };

  // WaveLogÂêåÊ≠•ÂäüËÉΩ
  const handleWaveLogSync = async (operation: 'download' | 'upload' | 'full_sync') => {
    if (isSyncing) return;
    
    try {
      setIsSyncing(true);
      setSyncError(null);
      setSyncSuccess(null);
      
      // Ë∞ÉÁî®WaveLogÂêåÊ≠•API
      const response = await fetch('/api/wavelog/sync', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ operation })
      });
      
      const result = await response.json() as WaveLogSyncResponse;
      
      if (result.success) {
        setSyncSuccess(result.message);
        // ÂêåÊ≠•ÊàêÂäüÂêéÈáçÊñ∞Âä†ËΩΩQSOÊï∞ÊçÆ
        await loadQSOs();
        await loadStatistics();
        
        console.log(`üìä WaveLogÂêåÊ≠•ÊàêÂäü: ${operation}`, result);
      } else {
        setSyncError(result.message || 'ÂêåÊ≠•Â§±Ë¥•');
      }
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'WaveLogÂêåÊ≠•Â§±Ë¥•';
      console.error('WaveLogÂêåÊ≠•Â§±Ë¥•:', error);
      setSyncError(errorMessage);
    } finally {
      setIsSyncing(false);
    }
  };

  // Ëá™Âä®Ê∏ÖÈô§ÊàêÂäü/ÈîôËØØÊ∂àÊÅØ
  useEffect(() => {
    if (syncSuccess) {
      const timer = setTimeout(() => setSyncSuccess(null), 5000);
      return () => clearTimeout(timer);
    }
  }, [syncSuccess]);

  useEffect(() => {
    if (syncError) {
      const timer = setTimeout(() => setSyncError(null), 10000);
      return () => clearTimeout(timer);
    }
  }, [syncError]);

  // Á≠õÈÄâÊéßÂà∂
  const handleFilterChange = (key: keyof QSOFilters, value: string | undefined) => {
    setFilters(prev => ({
      ...prev,
      [key]: value || undefined,
    }));
    setCurrentPage(1); // ÈáçÁΩÆÂà∞Á¨¨‰∏ÄÈ°µ
  };

  const clearFilters = () => {
    setFilters({});
    setCurrentPage(1);
  };

  // ÊâìÂºÄÁºñËæë Modal
  const handleEditClick = (qso: QSORecord) => {
    setEditingQSO(qso);
    setEditFormData({
      callsign: qso.callsign,
      grid: qso.grid,
      frequency: qso.frequency,
      mode: qso.mode,
      startTime: qso.startTime,
      endTime: qso.endTime,
      reportSent: qso.reportSent,
      reportReceived: qso.reportReceived,
      messages: qso.messages,
    });
    setIsEditModalOpen(true);
  };

  // ‰øùÂ≠òÁºñËæë
  const handleEditSave = async () => {
    if (!editingQSO) return;

    try {
      setIsEditSaving(true);
      await api.updateQSO(effectiveLogBookId, editingQSO.id, editFormData);

      // ÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
      await loadQSOs();
      await loadStatistics();

      // ÂÖ≥Èó≠ Modal
      setIsEditModalOpen(false);
      setEditingQSO(null);
      setEditFormData({});

      console.log('‚úÖ QSOËÆ∞ÂΩïÊõ¥Êñ∞ÊàêÂäü');
    } catch (error) {
      console.error('Êõ¥Êñ∞QSOËÆ∞ÂΩïÂ§±Ë¥•:', error);
      setError(error instanceof Error ? error.message : 'Êõ¥Êñ∞QSOËÆ∞ÂΩïÂ§±Ë¥•');
    } finally {
      setIsEditSaving(false);
    }
  };

  // ÊâìÂºÄÂà†Èô§Á°ÆËÆ§ Modal
  const handleDeleteClick = (qso: QSORecord) => {
    setDeletingQSO(qso);
    setIsDeleteModalOpen(true);
  };

  // Á°ÆËÆ§Âà†Èô§
  const handleDeleteConfirm = async () => {
    if (!deletingQSO) return;

    try {
      setIsDeleting(true);
      await api.deleteQSO(effectiveLogBookId, deletingQSO.id);

      // ÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ
      await loadQSOs();
      await loadStatistics();

      // ÂÖ≥Èó≠ Modal
      setIsDeleteModalOpen(false);
      setDeletingQSO(null);

      console.log('‚úÖ QSOËÆ∞ÂΩïÂà†Èô§ÊàêÂäü');
    } catch (error) {
      console.error('Âà†Èô§QSOËÆ∞ÂΩïÂ§±Ë¥•:', error);
      setError(error instanceof Error ? error.message : 'Âà†Èô§QSOËÆ∞ÂΩïÂ§±Ë¥•');
    } finally {
      setIsDeleting(false);
    }
  };

  // ÊâìÂºÄÂ§ñÈÉ®ÈìæÊé•ÁöÑÂáΩÊï∞
  const openExternalLink = (url: string) => {
    if (isElectron()) {
      // ElectronÁéØÂ¢ÉÔºöÂ∞ùËØï‰ΩøÁî®shell.openExternal
      if (typeof window !== 'undefined' && (window as any).electronAPI?.shell?.openExternal) {
        (window as any).electronAPI.shell.openExternal(url);
      } else {
        // Â¶ÇÊûúshell API‰∏çÂèØÁî®ÔºåÂõûÈÄÄÂà∞window.open
        console.warn('Electron shell API‰∏çÂèØÁî®ÔºåÂõûÈÄÄÂà∞window.open');
        window.open(url, '_blank');
      }
    } else {
      // ÊµèËßàÂô®ÁéØÂ¢ÉÔºö‰ΩøÁî®window.open
      window.open(url, '_blank');
    }
  };

  // Ê†ºÂºèÂåñÊó•ÊúüÊòæÁ§∫
  const formatDateTime = (timestamp: number, compact = false) => {
    if (compact) {
      // ÁßªÂä®Á´ØÁ¥ßÂáëÊ†ºÂºè
      return new Date(timestamp).toLocaleString('zh-CN', {
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'UTC'
      });
    }
    // Ê°åÈù¢Á´ØÂÆåÊï¥Ê†ºÂºè
    return new Date(timestamp).toLocaleString('zh-CN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'UTC'
    }) + ' UTC';
  };

  // Ê†ºÂºèÂåñÈ¢ëÁéáÊòæÁ§∫
  const formatFrequency = (frequencyHz: number) => {
    if (frequencyHz >= 1_000_000_000) {
      // Â§ß‰∫éÁ≠â‰∫é1GHz - ‰øùÁïô6‰ΩçÂ∞èÊï∞ÔºåÂéªÈô§Â∞æÈöèÈõ∂
      const ghz = frequencyHz / 1_000_000_000;
      return `${parseFloat(ghz.toFixed(6))} GHz`;
    } else if (frequencyHz >= 1_000_000) {
      // Â§ß‰∫éÁ≠â‰∫é1MHz - ‰øùÁïô6‰ΩçÂ∞èÊï∞ÔºåÂéªÈô§Â∞æÈöèÈõ∂
      const mhz = frequencyHz / 1_000_000;
      return `${parseFloat(mhz.toFixed(6))} MHz`;
    } else if (frequencyHz >= 1_000) {
      // Â§ß‰∫éÁ≠â‰∫é1KHz - ‰øùÁïô3‰ΩçÂ∞èÊï∞ÔºåÂéªÈô§Â∞æÈöèÈõ∂
      const khz = frequencyHz / 1_000;
      return `${parseFloat(khz.toFixed(3))} KHz`;
    } else {
      // Â∞è‰∫é1KHzÔºåÊòæÁ§∫Hz
      return `${frequencyHz} Hz`;
    }
  };

  // Ë°®Ê†ºÂàóÂÆö‰πâÔºàÂìçÂ∫îÂºèÔºâ
  const columns = [
    { key: 'startTime', label: 'Êó∂Èó¥ (UTC)', sortable: true, hideOnMobile: false },
    { key: 'callsign', label: 'ÂëºÂè∑', sortable: true, hideOnMobile: false },
    { key: 'grid', label: 'ÁΩëÊ†º', sortable: true, hideOnMobile: true },
    { key: 'frequency', label: 'È¢ëÁéá', sortable: true, hideOnMobile: false },
    { key: 'mode', label: 'Ê®°Âºè', sortable: true, hideOnMobile: true },
    { key: 'reportSent', label: 'ÂèëÈÄÅÊä•Âëä', sortable: false, hideOnMobile: true },
    { key: 'reportReceived', label: 'Êé•Êî∂Êä•Âëä', sortable: false, hideOnMobile: true },
    { key: 'actions', label: 'Êìç‰Ωú', sortable: false, hideOnMobile: false },
  ];

  // Ê∏≤ÊüìÂçïÂÖÉÊ†ºÂÜÖÂÆπ
  const renderCell = React.useCallback((qso: QSORecord, columnKey: React.Key) => {
    const cellValue = qso[columnKey as keyof QSORecord];

    switch (columnKey) {
      case "startTime":
        return (
          <div className="flex flex-col">
            <span className="hidden md:inline">{formatDateTime(qso.startTime)}</span>
            <span className="md:hidden text-xs">{formatDateTime(qso.startTime, true)}</span>
          </div>
        );
      case "callsign":
        return (
          <div className="font-semibold flex items-center gap-1 md:gap-2">
            <span className="text-sm md:text-base">{qso.callsign}</span>
            <button
              onClick={(e) => {
                e.stopPropagation();
                openExternalLink(`https://www.qrz.com/db/${qso.callsign}`);
              }}
              className="text-default-400 hover:text-primary transition-colors"
              title={`Âú®QRZ.comÊü•Áúã ${qso.callsign} ÁöÑ‰ø°ÊÅØ`}
            >
              <FontAwesomeIcon icon={faExternalLinkAlt} size="sm" />
            </button>
          </div>
        );
      case "grid":
        return qso.grid ? (
          <Chip size="sm" variant="flat" color="primary">
            {qso.grid}
          </Chip>
        ) : '-';
      case "frequency":
        return qso.frequency ? (
          <span className="text-xs md:text-sm whitespace-nowrap">
            {formatFrequency(qso.frequency)}
          </span>
        ) : '-';
      case "mode":
        return (
          <Chip size="sm" variant="flat" color="secondary">
            {qso.mode}
          </Chip>
        );
      case "reportSent":
        return qso.reportSent || '-';
      case "reportReceived":
        return qso.reportReceived || '-';
      case "actions":
        return (
          <div className="flex items-center gap-1 md:gap-2">
            <Tooltip content="ÁºñËæë">
              <Button
                size="sm"
                variant="light"
                isIconOnly
                onPress={() => handleEditClick(qso)}
                className="min-w-unit-8 w-8 h-8"
              >
                <FontAwesomeIcon icon={faEdit} className="text-primary text-sm" />
              </Button>
            </Tooltip>
            <Tooltip content="Âà†Èô§">
              <Button
                size="sm"
                variant="light"
                color="danger"
                isIconOnly
                onPress={() => handleDeleteClick(qso)}
                className="min-w-unit-8 w-8 h-8"
              >
                <FontAwesomeIcon icon={faTrash} className="text-sm" />
              </Button>
            </Tooltip>
          </div>
        );
      default:
        return cellValue;
    }
  }, []);

  // È°∂ÈÉ®ÂÜÖÂÆπÔºöÊ†áÈ¢òÂíåÊìç‰ΩúÂ∑•ÂÖ∑
  const topContent = React.useMemo(() => {
    return (
      <div className="flex flex-col gap-4">
        {/* Ê†áÈ¢òÂíåÊìç‰ΩúÊåâÈíÆ */}
        <div className="flex flex-col md:flex-row md:justify-between md:items-center gap-4">
          <div className="flex items-center gap-3">
            <h1 className="text-xl md:text-2xl font-bold text-foreground">
              ÈÄöËÅîÊó•Âøó
            </h1>
            {operatorCallsign && (
              <div className="flex items-center gap-2">
                <span className="text-default-500 hidden md:inline">-</span>
                <div className="bg-primary-50 dark:bg-primary-100/20 text-primary-600 dark:text-primary-400 px-2 md:px-3 py-1 md:py-1.5 rounded-full text-xs md:text-sm font-mono font-medium">
                  {operatorCallsign}
                </div>
              </div>
            )}
          </div>

          <div className="flex items-center gap-2 overflow-x-visible overflow-y-visible pb-2 md:pb-0">
            {/* ÂèØÂ±ïÂºÄÁöÑÊêúÁ¥¢Ê°Ü */}
            {isSearchExpanded ? (
              <Input
                autoFocus
                isClearable
                size="sm"
                className="w-40 md:w-64 transition-all duration-200"
                placeholder="ÊêúÁ¥¢ÂëºÂè∑..."
                startContent={<SearchIcon />}
                value={filters.callsign || ''}
                onClear={() => handleFilterChange('callsign', undefined)}
                onValueChange={(value) => handleFilterChange('callsign', value)}
                onBlur={() => {
                  if (!filters.callsign) {
                    setIsSearchExpanded(false);
                  }
                }}
              />
            ) : (
              <Button
                variant="flat"
                size="sm"
                startContent={<SearchIcon className="hidden md:inline" />}
                onPress={() => setIsSearchExpanded(true)}
                className="transition-all duration-200 min-w-0"
              >
                <span className="hidden md:inline">ÊêúÁ¥¢</span>
                <SearchIcon className="md:hidden" />
              </Button>
            )}
            
            {/* Á≠õÈÄâÊåâÈíÆ */}
            <Dropdown>
              <DropdownTrigger>
                <Button
                  variant="flat"
                  size="sm"
                  endContent={<FontAwesomeIcon icon={faChevronDown} className="text-default-400 text-xs hidden md:inline" />}
                  color={filters.band ? "primary" : "default"}
                  className="min-w-0"
                >
                  <span className="hidden md:inline">È¢ëÊÆµ{filters.band ? `: ${filters.band}` : ''}</span>
                  <span className="md:hidden">{filters.band || 'È¢ëÊÆµ'}</span>
                </Button>
              </DropdownTrigger>
              <DropdownMenu
                aria-label="È¢ëÊÆµÁ≠õÈÄâ"
                selectedKeys={filters.band ? [filters.band] : []}
                selectionMode="single"
                onSelectionChange={(keys) => {
                  const selected = Array.from(keys as Set<string>);
                  handleFilterChange('band', selected[0]);
                }}
              >
                <DropdownItem key="">ÂÖ®ÈÉ®È¢ëÊÆµ</DropdownItem>
                <DropdownItem key="160m">160m (1.8MHz)</DropdownItem>
                <DropdownItem key="80m">80m (3.5MHz)</DropdownItem>
                <DropdownItem key="60m">60m (5MHz)</DropdownItem>
                <DropdownItem key="40m">40m (7MHz)</DropdownItem>
                <DropdownItem key="30m">30m (10MHz)</DropdownItem>
                <DropdownItem key="20m">20m (14MHz)</DropdownItem>
                <DropdownItem key="17m">17m (18MHz)</DropdownItem>
                <DropdownItem key="15m">15m (21MHz)</DropdownItem>
                <DropdownItem key="12m">12m (24MHz)</DropdownItem>
                <DropdownItem key="10m">10m (28MHz)</DropdownItem>
                <DropdownItem key="6m">6m (50MHz)</DropdownItem>
                <DropdownItem key="4m">4m (70MHz)</DropdownItem>
                <DropdownItem key="2m">2m (144MHz)</DropdownItem>
                <DropdownItem key="1.25m">1.25m (222MHz)</DropdownItem>
                <DropdownItem key="70cm">70cm (430MHz)</DropdownItem>
                <DropdownItem key="33cm">33cm (902MHz)</DropdownItem>
                <DropdownItem key="23cm">23cm (1.2GHz)</DropdownItem>
              </DropdownMenu>
            </Dropdown>
            
            <Dropdown>
              <DropdownTrigger>
                <Button
                  variant="flat"
                  size="sm"
                  endContent={<FontAwesomeIcon icon={faChevronDown} className="text-default-400 text-xs hidden md:inline" />}
                  color={filters.mode ? "primary" : "default"}
                  className="min-w-0"
                >
                  <span className="hidden md:inline">Ê®°Âºè{filters.mode ? `: ${filters.mode}` : ''}</span>
                  <span className="md:hidden">{filters.mode || 'Ê®°Âºè'}</span>
                </Button>
              </DropdownTrigger>
              <DropdownMenu
                aria-label="Ê®°ÂºèÁ≠õÈÄâ"
                selectedKeys={filters.mode ? [filters.mode] : []}
                selectionMode="single"
                onSelectionChange={(keys) => {
                  const selected = Array.from(keys as Set<string>);
                  handleFilterChange('mode', selected[0]);
                }}
              >
                <DropdownItem key="">ÂÖ®ÈÉ®Ê®°Âºè</DropdownItem>
                <DropdownItem key="FT8">FT8</DropdownItem>
                <DropdownItem key="FT4">FT4</DropdownItem>
              </DropdownMenu>
            </Dropdown>
            
            {Object.keys(filters).length > 0 && (
              <Button
                variant="light"
                color="danger"
                size="sm"
                onPress={clearFilters}
                className="min-w-0 whitespace-nowrap"
              >
                <span className="hidden md:inline">Ê∏ÖÈô§Á≠õÈÄâ</span>
                <span className="md:hidden">Ê∏ÖÈô§</span>
              </Button>
            )}
            
            {/* WaveLogÂêåÊ≠•ÊåâÈíÆ */}
            <Dropdown>
              <DropdownTrigger>
                <Button
                  color="secondary"
                  variant="bordered"
                  size="sm"
                  isLoading={isSyncing}
                  startContent={<FontAwesomeIcon icon={faSync} className={isSyncing ? 'animate-spin' : ''} />}
                  className="min-w-0"
                >
                  <span className="hidden lg:inline">WaveLogÂêåÊ≠•</span>
                  <span className="lg:hidden hidden md:inline">ÂêåÊ≠•</span>
                </Button>
              </DropdownTrigger>
              <DropdownMenu
                aria-label="WaveLogÂêåÊ≠•Êìç‰Ωú"
                onAction={(key) => handleWaveLogSync(key as 'download' | 'upload' | 'full_sync')}
              >
                <DropdownItem 
                  key="download"
                  startContent={<FontAwesomeIcon icon={faDownload} className="text-primary" />}
                  description="‰ªéWaveLog‰∏ãËΩΩÊúÄÊñ∞ÁöÑQSOËÆ∞ÂΩï"
                >
                  ‰∏ãËΩΩÂêåÊ≠•
                </DropdownItem>
                <DropdownItem 
                  key="upload"
                  startContent={<FontAwesomeIcon icon={faUpload} className="text-secondary" />}
                  description="‰∏ä‰º†Êú¨Âú∞QSOËÆ∞ÂΩïÂà∞WaveLog"
                >
                  ‰∏ä‰º†ÂêåÊ≠•
                </DropdownItem>
                <DropdownItem 
                  key="full_sync"
                  startContent={<FontAwesomeIcon icon={faSync} className="text-warning" />}
                  description="ÂèåÂêëÂÆåÊï¥ÂêåÊ≠•"
                >
                  ÂÆåÊï¥ÂêåÊ≠•
                </DropdownItem>
              </DropdownMenu>
            </Dropdown>
            
            <Dropdown>
              <DropdownTrigger>
                <Button
                  color="primary"
                  variant="bordered"
                  size="sm"
                  isLoading={isExporting}
                  disabled={qsos.length === 0}
                  className="min-w-0"
                  startContent={<FontAwesomeIcon icon={faDownload} className="md:hidden" />}
                >
                  <span className="hidden md:inline">ÂØºÂá∫</span>
                </Button>
              </DropdownTrigger>
              <DropdownMenu
                aria-label="ÂØºÂá∫Ê†ºÂºè"
                onAction={(key) => handleExport(key as 'adif' | 'csv')}
              >
                <DropdownItem key="adif">ADIF Ê†ºÂºè</DropdownItem>
                <DropdownItem key="csv">CSV Ê†ºÂºè</DropdownItem>
              </DropdownMenu>
            </Dropdown>
          </div>
        </div>

        {/* ÁªüËÆ°‰ø°ÊÅØ */}
        <div className="flex flex-col md:flex-row md:justify-between md:items-center gap-2 text-xs md:text-small text-default-500">
          <span>
            {hasFilters
              ? `Á≠õÈÄâÁªìÊûú: ${totalRecords} Êù° / ÊÄªËÆ°: ${actualTotalRecords} Êù°ÈÄöËÅîËÆ∞ÂΩï`
              : `ÂÖ± ${actualTotalRecords} Êù°ÈÄöËÅîËÆ∞ÂΩï`
            }
          </span>
          {statistics && (
            <span className="flex flex-wrap gap-2 md:gap-0">
              <span>ÂîØ‰∏ÄÂëºÂè∑: {statistics.uniqueCallsigns}</span>
              {statistics.lastQSO && (
                <span className="hidden md:inline"> | ÊúÄËøëÈÄöËÅî: {new Date(statistics.lastQSO).toLocaleDateString('zh-CN', { timeZone: 'UTC' })} UTC</span>
              )}
            </span>
          )}
        </div>
      </div>
    );
  }, [
    operatorCallsign,
    isSearchExpanded,
    filters.callsign,
    filters.band, 
    filters.mode,
    totalRecords,
    actualTotalRecords,
    hasFilters,
    statistics,
    isExporting,
    handleFilterChange,
    clearFilters,
    handleExport
  ]);

  // Â∫ïÈÉ®ÂÜÖÂÆπÔºöÂàÜÈ°µ
  const bottomContent = React.useMemo(() => {
    console.log('üìä [LogbookViewer] Ê∏≤ÊüìÂàÜÈ°µÁªÑ‰ª∂:', { 
      currentPage, 
      totalPages, 
      showPagination: totalPages > 1 
    });
    
    // Â¶ÇÊûúÂè™Êúâ‰∏ÄÈ°µÔºå‰∏çÊòæÁ§∫ÂàÜÈ°µÁªÑ‰ª∂
    if (totalPages <= 1) {
      return null;
    }
    
    return (
      <div className="py-2 px-2 flex flex-col md:flex-row justify-between items-center gap-2">
        <Pagination
          isCompact
          showControls
          showShadow
          color="primary"
          page={currentPage}
          total={totalPages}
          onChange={(page) => {
            console.log('üìä [LogbookViewer] ÂàÜÈ°µÂàáÊç¢:', { from: currentPage, to: page });
            setCurrentPage(page);
          }}
          classNames={{
            wrapper: "gap-0 overflow-visible h-8",
            item: "w-8 h-8 text-xs min-w-8",
            cursor: "shadow-sm",
          }}
        />
        <div className="flex gap-2">
          <Button
            size="sm"
            variant="flat"
            onPress={() => {
              console.log('üìä [LogbookViewer] Ë∑≥ËΩ¨Âà∞Á¨¨‰∏ÄÈ°µ');
              setCurrentPage(1);
            }}
            isDisabled={currentPage === 1 || totalPages <= 1}
            className="min-w-0 text-xs md:text-sm"
          >
            <span className="hidden md:inline">Á¨¨‰∏ÄÈ°µ</span>
            <span className="md:hidden">È¶ñÈ°µ</span>
          </Button>
          <Button
            size="sm"
            variant="flat"
            onPress={() => {
              console.log('üìä [LogbookViewer] Ë∑≥ËΩ¨Âà∞ÊúÄÂêéÈ°µ:', totalPages);
              setCurrentPage(totalPages);
            }}
            isDisabled={currentPage === totalPages || totalPages <= 1}
            className="min-w-0 text-xs md:text-sm"
          >
            <span className="hidden md:inline">ÊúÄÂêéÈ°µ</span>
            <span className="md:hidden">Â∞æÈ°µ</span>
          </Button>
        </div>
      </div>
    );
  }, [currentPage, totalPages]);

  // ËÆ°ÁÆóÂä†ËΩΩÁä∂ÊÄÅÁöÑÂÜÖÂÆπ
  const loadingState = loading ? "loading" : "idle";

  // Â¶ÇÊûúÊúâÈîôËØØÔºåÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
  if (error) {
    return (
      <div className="h-full flex items-center justify-center p-6 max-w-7xl mx-auto">
        <Alert
          color="danger"
          title="Âä†ËΩΩÂ§±Ë¥•"
          description={error}
          endContent={
            <Button
              color="danger"
              variant="light"
              onPress={() => {
                setError(null);
                loadQSOs();
                loadStatistics();
              }}
            >
              ÈáçËØï
            </Button>
          }
        />
      </div>
    );
  }

  return (
    <div className="p-2 md:p-4 lg:p-6 max-w-7xl mx-auto">
      {/* ÈÄöÁü•Âå∫Âüü */}
      {syncSuccess && (
        <Alert
          color="success"
          variant="flat"
          className="w-full mb-4"
          title="WaveLogÂêåÊ≠•ÊàêÂäü"
          description={syncSuccess}
          isClosable
          onClose={() => setSyncSuccess(null)}
        />
      )}
      
      {syncError && (
        <Alert
          color="danger"
          variant="flat"
          className="w-full mb-4"
          title="WaveLogÂêåÊ≠•Â§±Ë¥•"
          description={syncError}
          isClosable
          onClose={() => setSyncError(null)}
        />
      )}
      
      {exportError && (
        <Alert
          color="danger"
          variant="flat"
          className="w-full mb-4"
          title="ÂØºÂá∫Â§±Ë¥•"
          description={exportError}
          isClosable
          onClose={() => setExportError(null)}
        />
      )}

      {/* Ë°®Ê†º - Âõ∫ÂÆöÈ´òÂ∫¶ */}
      <Table
        aria-label="QSOËÆ∞ÂΩïË°®Ê†º"
        isHeaderSticky
        bottomContent={bottomContent}
        bottomContentPlacement="outside"
        classNames={{
          wrapper: "max-h-[calc(100vh-280px)] md:max-h-[calc(100vh-228px)] overflow-auto",
          base: "overflow-x-visible",
          table: "min-w-full",
        }}
        sortDescriptor={sortDescriptor}
        topContent={topContent}
        topContentPlacement="outside"
        onSortChange={(descriptor) => setSortDescriptor(descriptor as any)}
      >
        <TableHeader columns={columns}>
          {(column) => (
            <TableColumn
              key={column.key}
              allowsSorting={column.sortable}
              className={column.hideOnMobile ? 'hidden md:table-cell' : ''}
            >
              {column.label}
            </TableColumn>
          )}
        </TableHeader>
        <TableBody
          items={qsos}
          loadingContent={<Spinner />}
          loadingState={loadingState}
          emptyContent={"ÊöÇÊó†ÈÄöËÅîËÆ∞ÂΩï"}
        >
          {(qso) => (
            <TableRow key={qso.id}>
              {(columnKey) => {
                const column = columns.find(c => c.key === columnKey);
                return (
                  <TableCell className={column?.hideOnMobile ? 'hidden md:table-cell' : ''}>
                    {renderCell(qso, columnKey)}
                  </TableCell>
                );
              }}
            </TableRow>
          )}
        </TableBody>
      </Table>

      {/* ÁºñËæë Modal */}
      <Modal
        isOpen={isEditModalOpen}
        onClose={() => {
          setIsEditModalOpen(false);
          setEditingQSO(null);
          setEditFormData({});
        }}
        size="2xl"
        scrollBehavior="inside"
      >
        <ModalContent>
          <ModalHeader>
            <h3 className="text-lg font-semibold">ÁºñËæë QSO ËÆ∞ÂΩï</h3>
          </ModalHeader>
          <ModalBody>
            <div className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Input
                  label="ÂëºÂè∑"
                  value={editFormData.callsign || ''}
                  onChange={(e) => setEditFormData({ ...editFormData, callsign: e.target.value })}
                  isRequired
                />
                <Input
                  label="ÁΩëÊ†ºÂùêÊ†á"
                  value={editFormData.grid || ''}
                  onChange={(e) => setEditFormData({ ...editFormData, grid: e.target.value })}
                />
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Input
                  label="È¢ëÁéá (Hz)"
                  type="number"
                  value={editFormData.frequency?.toString() || ''}
                  onChange={(e) => setEditFormData({ ...editFormData, frequency: parseInt(e.target.value) || 0 })}
                  isRequired
                />
                <Select
                  label="Ê®°Âºè"
                  selectedKeys={editFormData.mode ? [editFormData.mode] : []}
                  onSelectionChange={(keys) => {
                    const selected = Array.from(keys as Set<string>)[0];
                    setEditFormData({ ...editFormData, mode: selected as string });
                  }}
                  isRequired
                >
                  <SelectItem key="FT8">FT8</SelectItem>
                  <SelectItem key="FT4">FT4</SelectItem>
                  <SelectItem key="RTTY">RTTY</SelectItem>
                  <SelectItem key="CW">CW</SelectItem>
                  <SelectItem key="SSB">SSB</SelectItem>
                </Select>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <Input
                  label="ÂèëÈÄÅ‰ø°Âè∑Êä•Âëä"
                  value={editFormData.reportSent || ''}
                  onChange={(e) => setEditFormData({ ...editFormData, reportSent: e.target.value })}
                />
                <Input
                  label="Êé•Êî∂‰ø°Âè∑Êä•Âëä"
                  value={editFormData.reportReceived || ''}
                  onChange={(e) => setEditFormData({ ...editFormData, reportReceived: e.target.value })}
                />
              </div>

              <div className="p-3 bg-warning-50 dark:bg-warning-100/20 border border-warning-200 dark:border-warning-400/30 rounded-lg">
                <p className="text-warning-700 dark:text-warning-400 text-sm">
                  ‚ö†Ô∏è Ê≥®ÊÑè:‰øÆÊîπ QSO ËÆ∞ÂΩïÂèØËÉΩ‰ºöÂΩ±ÂìçÁªüËÆ°Êï∞ÊçÆÁöÑÂáÜÁ°ÆÊÄß,ËØ∑Ë∞®ÊÖéÊìç‰Ωú„ÄÇ
                </p>
              </div>
            </div>
          </ModalBody>
          <ModalFooter>
            <Button
              variant="flat"
              onPress={() => {
                setIsEditModalOpen(false);
                setEditingQSO(null);
                setEditFormData({});
              }}
            >
              ÂèñÊ∂à
            </Button>
            <Button
              color="primary"
              onPress={handleEditSave}
              isLoading={isEditSaving}
              isDisabled={!editFormData.callsign || !editFormData.frequency}
            >
              ‰øùÂ≠ò
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* Âà†Èô§Á°ÆËÆ§ Modal */}
      <Modal
        isOpen={isDeleteModalOpen}
        onClose={() => {
          setIsDeleteModalOpen(false);
          setDeletingQSO(null);
        }}
        size="sm"
      >
        <ModalContent>
          <ModalHeader>
            <h3 className="text-lg font-semibold text-danger">Âà†Èô§ QSO ËÆ∞ÂΩï</h3>
          </ModalHeader>
          <ModalBody>
            {deletingQSO && (
              <div className="space-y-3">
                <p className="text-default-600">
                  Á°ÆÂÆöË¶ÅÂà†Èô§‰∏é <span className="font-semibold text-danger">{deletingQSO.callsign}</span> ÁöÑÈÄöËÅîËÆ∞ÂΩïÂêó?
                </p>
                <div className="p-3 bg-default-100 rounded-lg space-y-1">
                  <p className="text-sm"><span className="font-medium">Êó∂Èó¥:</span> {formatDateTime(deletingQSO.startTime)}</p>
                  <p className="text-sm"><span className="font-medium">È¢ëÁéá:</span> {formatFrequency(deletingQSO.frequency)}</p>
                  <p className="text-sm"><span className="font-medium">Ê®°Âºè:</span> {deletingQSO.mode}</p>
                </div>
                <div className="p-3 bg-danger-50 dark:bg-danger-100/20 border border-danger-200 dark:border-danger-400/30 rounded-lg">
                  <p className="text-danger-700 dark:text-danger-400 text-sm">
                    ‚ö†Ô∏è Ê≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄ,Âà†Èô§ÂêéËØ•ËÆ∞ÂΩïÂ∞ÜÊ∞∏‰πÖ‰∏¢Â§±„ÄÇ
                  </p>
                </div>
              </div>
            )}
          </ModalBody>
          <ModalFooter>
            <Button
              variant="flat"
              onPress={() => {
                setIsDeleteModalOpen(false);
                setDeletingQSO(null);
              }}
            >
              ÂèñÊ∂à
            </Button>
            <Button
              color="danger"
              onPress={handleDeleteConfirm}
              isLoading={isDeleting}
            >
              Á°ÆËÆ§Âà†Èô§
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>
    </div>
  );
};

export default LogbookViewer;
